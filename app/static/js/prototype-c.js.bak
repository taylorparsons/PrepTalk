/**
 * PrepTalk Prototype C - Confident Pro
 *
 * Production-quality JavaScript for the UI prototype.
 * Handles session persistence, navigation, file uploads, and UI interactions.
 *
 * @module prototype-c
 */

// ============================================
// CONSTANTS
// ============================================

/** LocalStorage key for session data */
const STORAGE_KEY = 'preptalk_session';

/** Default session state structure */
const DEFAULT_STATE = {
  currentScreen: 'screen-welcome',
  resumeUploaded: false,
  resumeFileName: null,
  jobUploaded: false,
  jobFileName: null,
  topicsCompleted: [],
  questionsAnswered: 0,
  totalTime: 0,
  insights: {
    continueDoing: [],
    doMoreOf: [],
    startDoing: [],
    doLessOf: [],
    stopDoing: []
  },
  lastUpdated: null
};

// ============================================
// SESSION STATE MANAGEMENT
// ============================================

/**
 * Retrieves the current session state from localStorage.
 * Returns default state if no session exists or parsing fails.
 *
 * @returns {Object} Current session state
 */
function getState() {
  try {
    const stored = localStorage.getItem(STORAGE_KEY);
    return stored ? JSON.parse(stored) : { ...DEFAULT_STATE };
  } catch (error) {
    console.warn('PrepTalk: Failed to parse session state, using defaults', error);
    return { ...DEFAULT_STATE };
  }
}

/**
 * Saves updates to the session state.
 * Merges updates with current state and updates timestamp.
 *
 * @param {Object} updates - Partial state updates to merge
 */
function saveState(updates) {
  const current = getState();
  const newState = {
    ...current,
    ...updates,
    lastUpdated: Date.now()
  };
  localStorage.setItem(STORAGE_KEY, JSON.stringify(newState));
}

/**
 * Clears all session data from localStorage.
 */
function clearState() {
  localStorage.removeItem(STORAGE_KEY);
}

// ============================================
// NAVIGATION
// ============================================

/**
 * Navigates to a screen by ID.
 * Hides all screens, shows the target, scrolls to top, and saves state.
 *
 * @param {string} screenId - The ID of the screen element to show
 */
function goToScreen(screenId) {
  const targetScreen = document.getElementById(screenId);

  if (!targetScreen) {
    console.warn(`PrepTalk: Screen "${screenId}" not found`);
    return;
  }

  // Hide all screens
  document.querySelectorAll('.screen').forEach(screen => {
    screen.classList.remove('active');
  });

  // Show target screen
  targetScreen.classList.add('active');

  // Scroll to top for clean transition
  window.scrollTo(0, 0);

  // Persist navigation state
  saveState({ currentScreen: screenId });
}

// ============================================
// FILE UPLOADS
// ============================================

/**
 * Handles resume file upload.
 * Updates dropzone UI and saves upload state.
 *
 * @param {HTMLInputElement} input - The file input element
 */
function handleResumeUpload(input) {
  if (input.files.length === 0) return;

  const file = input.files[0];
  const dropzone = document.getElementById('dropzone-resume');

  if (!dropzone) return;

  // Update UI
  dropzone.classList.add('has-file');

  const textEl = dropzone.querySelector('.dropzone-text');
  const hintEl = dropzone.querySelector('.dropzone-hint');

  if (textEl) textEl.textContent = file.name;
  if (hintEl) hintEl.textContent = 'File uploaded âœ“';

  // Save state
  saveState({
    resumeUploaded: true,
    resumeFileName: file.name
  });
}

/**
 * Handles job description file upload.
 * Updates dropzone UI and saves upload state.
 *
 * @param {HTMLInputElement} input - The file input element
 */
function handleJobUpload(input) {
  if (input.files.length === 0) return;

  const file = input.files[0];
  const dropzone = document.getElementById('dropzone-job');

  if (!dropzone) return;

  // Update UI
  dropzone.classList.add('has-file');

  const textEl = dropzone.querySelector('.dropzone-text');
  const hintEl = dropzone.querySelector('.dropzone-hint');

  if (textEl) textEl.textContent = file.name;
  if (hintEl) hintEl.textContent = 'File uploaded âœ“';

  // Save state
  saveState({
    jobUploaded: true,
    jobFileName: file.name
  });
}

// ============================================
// STATE RESTORATION
// ============================================

/**
 * Restores UI state from saved session.
 * Called on page load to resume previous session.
 */
function restoreState() {
  const state = getState();

  if (!state.lastUpdated) return;

  // Resume from last screen if it exists
  if (state.currentScreen) {
    const screen = document.getElementById(state.currentScreen);
    if (screen) {
      goToScreen(state.currentScreen);
    }
  }

  // Restore resume dropzone
  if (state.resumeUploaded) {
    const resumeDropzone = document.getElementById('dropzone-resume');
    if (resumeDropzone) {
      resumeDropzone.classList.add('has-file');
      const textEl = resumeDropzone.querySelector('.dropzone-text');
      const hintEl = resumeDropzone.querySelector('.dropzone-hint');
      if (textEl) textEl.textContent = state.resumeFileName || 'Resume uploaded';
      if (hintEl) hintEl.textContent = 'File ready âœ“';
    }
  }

  // Restore job dropzone
  if (state.jobUploaded) {
    const jobDropzone = document.getElementById('dropzone-job');
    if (jobDropzone) {
      jobDropzone.classList.add('has-file');
      const textEl = jobDropzone.querySelector('.dropzone-text');
      const hintEl = jobDropzone.querySelector('.dropzone-hint');
      if (textEl) textEl.textContent = state.jobFileName || 'Job description uploaded';
      if (hintEl) hintEl.textContent = 'File ready âœ“';
    }
  }
}

// ============================================
// PROGRESS RING TOOLTIPS
// ============================================

/**
 * Shows a tooltip for progress ring on hover.
 *
 * @param {string} text - Tooltip text to display
 */
function showRingTooltip(text) {
  const tooltip = document.getElementById('ring-tooltip');
  if (tooltip) {
    tooltip.textContent = text;
    tooltip.classList.add('visible');
  }
}

/**
 * Hides the progress ring tooltip.
 */
function hideRingTooltip() {
  const tooltip = document.getElementById('ring-tooltip');
  if (tooltip) {
    tooltip.classList.remove('visible');
  }
}

// ============================================
// PDF EXPORT
// ============================================

/**
 * Exports the session insights as a PDF report.
 * Template-based approach with proper page handling.
 */
function exportPDF() {
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF();

  // === DESIGN TOKENS ===
  const colors = {
    green: [45, 90, 71],
    blue: [74, 106, 138],
    dark: [30, 30, 30],
    gray: [120, 120, 120],
    light: [248, 248, 246],
    white: [255, 255, 255],
    border: [220, 220, 220]
  };

  const layout = {
    pageWidth: doc.internal.pageSize.getWidth(),
    pageHeight: doc.internal.pageSize.getHeight(),
    margin: 20,
    get contentWidth() { return this.pageWidth - (this.margin * 2); },
    lineHeight: 5,
    sectionGap: 12,
    itemGap: 5
  };

  let y = 0;
  let pageNum = 1;

  // === TEMPLATE FUNCTIONS ===

  function checkPageBreak(needed) {
    const footerSpace = 14;
    if (y + needed > layout.pageHeight - footerSpace) {
      addFooter();
      doc.addPage();
      pageNum++;
      y = layout.margin;
      addPageHeader();
    }
  }

  function addPageHeader() {
    if (pageNum > 1) {
      doc.setDrawColor(...colors.green);
      doc.setLineWidth(1.5);
      doc.circle(layout.margin + 6, y + 6, 5, 'S');
      doc.setTextColor(...colors.green);
      doc.setFontSize(12);
      doc.setFont('helvetica', 'bold');
      doc.text('PrepTalk', layout.margin + 16, y + 8);
      doc.setTextColor(...colors.gray);
      doc.setFontSize(8);
      doc.setFont('helvetica', 'normal');
      doc.text('Continued', layout.margin + 50, y + 8);
      y += 20;
    }
  }

  function addSection(title, subtitle, items, color) {
    const sectionHeight = 15 + (items.length * 14);
    checkPageBreak(sectionHeight);

    // Title
    doc.setTextColor(...color);
    doc.setFontSize(12);
    doc.setFont('helvetica', 'bold');
    doc.text(title, layout.margin, y);
    y += 5;

    // Subtitle
    doc.setTextColor(...colors.gray);
    doc.setFontSize(8);
    doc.setFont('helvetica', 'italic');
    doc.text(subtitle, layout.margin, y);
    y += 8;

    // Items
    doc.setTextColor(...colors.dark);
    doc.setFontSize(9);
    doc.setFont('helvetica', 'normal');
    items.forEach(item => {
      const lines = doc.splitTextToSize('â€¢ ' + item, layout.contentWidth - 10);
      lines.forEach(line => {
        doc.text(line, layout.margin + 4, y);
        y += layout.itemGap;
      });
      y += 1;
    });

    y += layout.sectionGap;
  }

  function addFooter() {
    const footerY = layout.pageHeight - 10;

    // Compact footer - one size up
    doc.setDrawColor(...colors.green);
    doc.setLineWidth(0.7);
    doc.circle(layout.margin + 3, footerY, 2, 'S');

    doc.setTextColor(...colors.gray);
    doc.setFontSize(7);
    doc.setFont('helvetica', 'italic');
    doc.text('You already have the stories. Now go tell them. â€” Prep', layout.margin + 8, footerY + 0.5);

    // Page number
    doc.setFont('helvetica', 'normal');
    const pageText = 'Page ' + pageNum;
    doc.text(pageText, layout.pageWidth - layout.margin - doc.getTextWidth(pageText), footerY + 0.5);
  }

  // === CONTENT DATA ===
  const sections = [
    {
      title: 'Continue',
      subtitle: 'These are working beautifully. Keep doing exactly this.',
      color: colors.blue,
      items: [
        'Your stories flow naturally and are easy to follow. Interviewers can track your thinking without getting lost.',
        'Using specific numbers like "23% improvement" sticks in memory far longer than saying "significant impact."',
        'Your pace is steady and grounded. That calm energy builds trust and makes you sound confident.'
      ]
    },
    {
      title: 'Lean Into',
      subtitle: "You're already doing this well. A bit more would make it shine.",
      color: colors.green,
      items: [
        'The payment integration story is your strongest. Use it for leadership, technical, and collaboration questions.',
        'Naming specific tools like Kubernetes and Terraform sounds more credible than "various technologies."',
        'Quantified outcomes are what interviewers remember when comparing candidates at the end of the day.'
      ]
    },
    {
      title: 'Add',
      subtitle: 'New elements that could elevate your answers.',
      color: colors.blue,
      items: [
        'A "lesson learned" ending shows self-awareness and growth mindset. Interviewers love candidates who reflect.',
        "Mentioning what you'd do differently demonstrates maturity and continuous improvement. It's disarming and authentic.",
        "Connecting your past to this role shows you've done your homework and can see yourself in their future."
      ]
    },
    {
      title: 'Refine',
      subtitle: 'Small adjustments that could tighten your stories.',
      color: colors.green,
      items: [
        'Your action moments are the most compelling part. Getting there faster gives you more time for the good stuff.'
      ]
    }
  ];

  // === RENDER PAGE 1 HEADER ===
  doc.setFillColor(...colors.green);
  doc.rect(0, 0, layout.pageWidth, 38, 'F');

  // Logo
  doc.setDrawColor(...colors.white);
  doc.setLineWidth(2.5);
  doc.circle(layout.margin + 10, 19, 8, 'S');

  // Title
  doc.setTextColor(...colors.white);
  doc.setFontSize(20);
  doc.setFont('helvetica', 'bold');
  doc.text('PrepTalk', layout.margin + 24, 22);

  // Date
  doc.setFontSize(9);
  doc.setFont('helvetica', 'normal');
  const date = new Date().toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
  doc.text(date, layout.pageWidth - layout.margin - doc.getTextWidth(date), 22);

  // Tagline
  doc.setFontSize(9);
  doc.text('Interview Practice Report', layout.margin, 34);

  // === NOTE FROM PREP ===
  y = 48;
  doc.setFillColor(...colors.light);
  doc.roundedRect(layout.margin, y, layout.contentWidth, 18, 2, 2, 'F');

  doc.setTextColor(...colors.green);
  doc.setFontSize(9);
  doc.setFont('helvetica', 'bold');
  doc.text('A note from Prep:', layout.margin + 6, y + 8);

  doc.setTextColor(...colors.dark);
  doc.setFont('helvetica', 'normal');
  doc.text("You did the hard part. You showed up. Here's what I noticed about your stories.", layout.margin + 6, y + 14);

  // === SESSION STATS ===
  y = 74;
  doc.setTextColor(...colors.dark);
  doc.setFontSize(10);
  doc.setFont('helvetica', 'bold');
  doc.text('Session Summary', layout.margin, y);
  y += 6;
  doc.setTextColor(...colors.gray);
  doc.setFontSize(9);
  doc.setFont('helvetica', 'normal');
  doc.text('Topics: 2 of 3   |   Questions: 5 of 6   |   Time: 18 min', layout.margin, y);

  // Divider
  y += 10;
  doc.setDrawColor(...colors.border);
  doc.line(layout.margin, y, layout.pageWidth - layout.margin, y);
  y += 12;

  // === RENDER SECTIONS ===
  sections.forEach(section => {
    addSection(section.title, section.subtitle, section.items, section.color);
  });

  // === FINAL FOOTER ===
  addFooter();

  // Save the PDF
  const filename = 'PrepTalk_Report_' + new Date().toISOString().split('T')[0] + '.pdf';
  doc.save(filename);
}

// ============================================
// END SESSION
// ============================================

/**
 * Shows the End Session screen with data preview.
 * Displays what data is stored locally.
 */
function showEndSession() {
  const preview = document.getElementById('data-preview');
  const state = getState();

  if (preview) {
    if (state.lastUpdated) {
      const data = {
        lastUpdated: new Date(state.lastUpdated).toLocaleString(),
        currentScreen: state.currentScreen,
        resumeUploaded: state.resumeUploaded,
        jobUploaded: state.jobUploaded,
        topicsCompleted: state.topicsCompleted || [],
        questionsAnswered: state.questionsAnswered || 0
      };
      preview.textContent = JSON.stringify(data, null, 2);
    } else {
      preview.textContent = 'No session data found.';
    }
  }

  goToScreen('screen-end');
}

/**
 * Keeps session data and shows confirmation.
 * Data remains in localStorage for future sessions.
 */
function keepDataAndClose() {
  alert(
    'Your progress has been saved! You can close this tab now.\n\n' +
    'When you return, we\'ll pick up where you left off.'
  );
}

/**
 * Deletes all session data after confirmation.
 * Clears localStorage and returns to welcome screen.
 */
function deleteDataAndClose() {
  const confirmed = confirm(
    'Are you sure you want to delete all session data?\n\n' +
    'This cannot be undone.'
  );

  if (confirmed) {
    clearState();
    alert(
      'All session data has been deleted.\n\n' +
      'You can safely close this tab now.'
    );
    goToScreen('screen-welcome');
  }
}

// ============================================
// STORY SHELF
// ============================================

const STORIES_KEY = 'preptalk_stories';
const FILLER_WORDS = ['um', 'uh', 'like', 'you know', 'so', 'basically', 'actually', 'right', 'i mean'];

/**
 * Demo stories to seed the Story Shelf for demonstration purposes.
 * These represent a realistic mix of story types and readiness levels.
 */
const DEMO_STORIES = [
  {
    id: 'demo_1',
    name: 'Payment Integration Launch',
    tags: ['leadership', 'technical', 'results-driven'],
    readiness: 92,
    fillersPerMinute: 1.2,
    fillerCounts: { um: 1, like: 1 },
    insight: 'Strong story with clear metrics. Interview-ready.',
    questionType: 'Leadership',
    created: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),
    practices: 4
  },
  {
    id: 'demo_2',
    name: 'Cross-Team Conflict Resolution',
    tags: ['conflict', 'collaboration', 'leadership'],
    readiness: 78,
    fillersPerMinute: 2.4,
    fillerCounts: { um: 2, you_know: 1 },
    insight: 'Good structure. Practice the resolution section once more.',
    questionType: 'Conflict',
    created: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString(),
    practices: 3
  },
  {
    id: 'demo_3',
    name: 'Database Migration Project',
    tags: ['technical', 'problem-solving', 'results-driven'],
    readiness: 85,
    fillersPerMinute: 1.8,
    fillerCounts: { so: 2, basically: 1 },
    insight: 'Technical details are crisp. Consider adding team dynamics.',
    questionType: 'Technical',
    created: new Date(Date.now() - 4 * 24 * 60 * 60 * 1000).toISOString(),
    practices: 3
  },
  {
    id: 'demo_4',
    name: 'Mentoring Junior Developer',
    tags: ['leadership', 'mentorship', 'growth'],
    readiness: 65,
    fillersPerMinute: 3.1,
    fillerCounts: { like: 3, um: 2 },
    insight: 'Great story choice. Practice the outcome section.',
    questionType: 'Leadership',
    created: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString(),
    practices: 2
  },
  {
    id: 'demo_5',
    name: 'Stakeholder Pushback on Timeline',
    tags: ['conflict', 'communication', 'negotiation'],
    readiness: 71,
    fillersPerMinute: 2.8,
    fillerCounts: { um: 2, right: 2 },
    insight: 'Strong opening. The compromise section needs polish.',
    questionType: 'Conflict',
    created: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),
    practices: 2
  },
  {
    id: 'demo_6',
    name: 'Product Launch Under Pressure',
    tags: ['leadership', 'pressure', 'results-driven'],
    readiness: 45,
    fillersPerMinute: 4.5,
    fillerCounts: { um: 4, like: 3, so: 2 },
    insight: 'Compelling story. Try slowing down during the crisis section.',
    questionType: 'Leadership',
    created: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000).toISOString(),
    practices: 1
  },
  {
    id: 'demo_7',
    name: 'API Redesign Initiative',
    tags: ['technical', 'innovation', 'collaboration'],
    readiness: 38,
    fillersPerMinute: 5.2,
    fillerCounts: { um: 5, basically: 3, you_know: 2 },
    insight: 'Just captured. Practice a few more times to build confidence.',
    questionType: 'Technical',
    created: new Date().toISOString(),
    practices: 1
  }
];

/**
 * Initialize demo stories if the shelf is empty.
 * Called on page load to seed realistic demonstration data.
 */
function initDemoStories() {
  const data = getStories();
  if (data.stories.length === 0) {
    data.stories = [...DEMO_STORIES];
    data.stats.sessions = 7;
    saveStories(data);
  }
}

/**
 * Get stories from localStorage
 */
function getStories() {
  try {
    const stored = localStorage.getItem(STORIES_KEY);
    return stored ? JSON.parse(stored) : { stories: [], stats: { sessions: 0 } };
  } catch (e) {
    return { stories: [], stats: { sessions: 0 } };
  }
}

/**
 * Save stories to localStorage
 */
function saveStories(data) {
  localStorage.setItem(STORIES_KEY, JSON.stringify(data));
}

// Current tag filter state
let currentTagFilter = 'all';

// Tag color mapping for visual distinction
const TAG_COLORS = {
  'leadership': '#2D8A5A',
  'technical': '#4A7A9A',
  'conflict': '#9A4A4A',
  'collaboration': '#7A5A9A',
  'results-driven': '#5A8A7A',
  'problem-solving': '#8A7A4A',
  'mentorship': '#4A9A8A',
  'communication': '#9A6A4A',
  'innovation': '#6A4A9A',
  'growth': '#4A8A6A',
  'negotiation': '#8A4A6A',
  'pressure': '#6A8A4A'
};

/**
 * Render the story shelf
 */
function renderStoryShelf() {
  const data = getStories();
  const shelf = document.getElementById('stories-shelf');
  const empty = document.getElementById('stories-empty');
  const stats = document.getElementById('stories-stats');
  const actions = document.getElementById('stories-actions');
  const fillerCard = document.getElementById('filler-trend-card');

  if (!shelf) return;

  if (data.stories.length === 0) {
    empty.style.display = 'block';
    stats.style.display = 'none';
    actions.style.display = 'none';
    fillerCard.style.display = 'none';
    // Hide sidebar rings and tag filter when empty
    const sidebarRings = document.getElementById('sidebar-rings-section');
    const tagFilterSection = document.getElementById('tag-filter-section');
    if (sidebarRings) sidebarRings.style.display = 'none';
    if (tagFilterSection) tagFilterSection.style.display = 'none';
    shelf.innerHTML = '';
    shelf.appendChild(empty);
    return;
  }

  empty.style.display = 'none';
  stats.style.display = 'flex';
  actions.style.display = 'block';

  // Show tag filter section
  const tagFilterSection = document.getElementById('tag-filter-section');
  if (tagFilterSection) {
    tagFilterSection.style.display = 'flex';
    renderTagFilter(data.stories);
  }

  // Show and update sidebar rings section
  const sidebarRings = document.getElementById('sidebar-rings-section');
  if (sidebarRings) {
    sidebarRings.style.display = 'block';
    renderProgressRings(data.stories);
  }

  // Filter stories by current tag
  const filteredStories = currentTagFilter === 'all'
    ? data.stories
    : data.stories.filter(s => s.tags.includes(currentTagFilter));

  // Update stats
  const readyCount = data.stories.filter(s => s.readiness >= 80).length;
  document.getElementById('stat-story-count').textContent = data.stories.length;
  document.getElementById('stat-ready-count').textContent = readyCount;
  document.getElementById('stat-practice-count').textContent = data.stats.sessions || 0;

  // Render story cards (clickable to practice)
  shelf.innerHTML = filteredStories.map(story => {
    const status = story.readiness >= 80 ? 'ready' : story.readiness >= 40 ? 'practicing' : 'new';
    const icon = status === 'ready' ? 'ðŸ“—' : status === 'practicing' ? 'ðŸ“˜' : 'ðŸ“™';
    const label = status === 'ready' ? 'Interview-ready' : status === 'practicing' ? 'Practicing' : 'Needs work';
    const practiceText = story.practices === 1 ? 'Practiced once' : `Practiced ${story.practices} times`;

    return `
      <div class="story-card" data-status="${status}" data-id="${story.id}"
           data-tags="${story.tags.join(',')}"
           onclick="openStoryPractice('${story.id}')" role="button" tabindex="0"
           onkeypress="if(event.key==='Enter')openStoryPractice('${story.id}')">
        <div class="story-card-header">
          <span class="story-card-icon">${icon}</span>
          <span class="story-card-name">${story.name}</span>
        </div>
        <div class="story-card-tags">
          ${story.tags.slice(0, 3).map(t => `<span class="story-tag" onclick="event.stopPropagation(); filterByTag('${t}')">${t}</span>`).join('')}
        </div>
        <div class="story-card-readiness">
          <div class="readiness-bar">
            <div class="readiness-fill" style="width: ${story.readiness}%"></div>
          </div>
          <span class="readiness-label">${label}</span>
        </div>
        <div class="story-card-meta">
          <span class="story-card-practices">${practiceText}</span>
          <span class="story-card-action">Click to practice â†’</span>
        </div>
      </div>
    `;
  }).join('');

  // Show message if filter returns no results
  if (filteredStories.length === 0 && currentTagFilter !== 'all') {
    shelf.innerHTML = `
      <div class="stories-empty stories-empty--filter">
        <p>No stories with tag "${currentTagFilter}"</p>
        <button class="btn btn-outline btn-sm" onclick="filterByTag('all')">Show all stories</button>
      </div>
    `;
  }

  // Update filler trend if we have data
  if (data.stories.length >= 2) {
    fillerCard.style.display = 'block';
    renderFillerTrend(data.stories);
  }

  // Update nav badge
  const navStories = document.getElementById('nav-stories');
  if (navStories && data.stories.length > 0) {
    navStories.innerHTML = `My Stories <span class="nav-badge">${data.stories.length}</span>`;
  }
}

/**
 * Render the Apple-style progress rings (sidebar version)
 */
function renderProgressRings(stories) {
  const totalCount = stories.length;
  const readyCount = stories.filter(s => s.readiness >= 80).length;

  // Calculate filtered count if a tag is selected
  const filteredStories = currentTagFilter === 'all'
    ? stories
    : stories.filter(s => s.tags.includes(currentTagFilter));
  const filteredCount = filteredStories.length;

  // Update center display based on filter
  const mainValue = document.getElementById('rings-main-value');
  const mainLabel = document.getElementById('rings-main-label');

  if (mainValue && mainLabel) {
    if (currentTagFilter === 'all') {
      mainValue.textContent = totalCount;
      mainLabel.textContent = totalCount === 1 ? 'Story' : 'Stories';
    } else {
      mainValue.textContent = filteredCount;
      mainLabel.textContent = currentTagFilter;
    }
  }

  // Calculate ring progress (max 10 stories = full ring for demo)
  const maxStories = 10;
  const totalProgress = Math.min(1, totalCount / maxStories);
  const readyProgress = totalCount > 0 ? readyCount / totalCount : 0;
  const filterProgress = totalCount > 0 ? filteredCount / totalCount : 0;

  // Animate rings (using sidebar radii: 70, 52, 34)
  animateRing('ring-total', totalProgress, 70);
  animateRing('ring-ready', readyProgress, 52);
  animateRing('ring-filter', filterProgress, 34);

  // Update legend
  const legendTotal = document.getElementById('legend-total');
  const legendReady = document.getElementById('legend-ready');
  if (legendTotal) legendTotal.textContent = totalCount;
  if (legendReady) legendReady.textContent = readyCount;

  // Show/hide filter legend
  const filterRow = document.getElementById('legend-filter-row');
  if (filterRow) {
    if (currentTagFilter !== 'all') {
      filterRow.style.display = 'flex';
      const filterText = document.getElementById('legend-filter-text');
      const filterValue = document.getElementById('legend-filter');
      if (filterText) filterText.textContent = currentTagFilter;
      if (filterValue) filterValue.textContent = filteredCount;

      // Update inner ring color based on tag
      const innerRing = document.getElementById('ring-filter');
      if (innerRing) innerRing.style.stroke = TAG_COLORS[currentTagFilter] || '#7A5A9A';
    } else {
      filterRow.style.display = 'none';
    }
  }

  // Update ring tooltips with current values
  updateRingTooltips(totalCount, readyCount, filteredCount);
}

/**
 * Update ring hover tooltip content
 */
function updateRingTooltips(total, ready, filtered) {
  const outerRing = document.getElementById('ring-total');
  const middleRing = document.getElementById('ring-ready');
  const innerRing = document.getElementById('ring-filter');

  if (outerRing) {
    outerRing.setAttribute('onmouseenter', `showStoriesRingTooltip('Total: ${total} stories collected')`);
  }
  if (middleRing) {
    middleRing.setAttribute('onmouseenter', `showStoriesRingTooltip('Interview-ready: ${ready} of ${total}')`);
  }
  if (innerRing && currentTagFilter !== 'all') {
    innerRing.setAttribute('onmouseenter', `showStoriesRingTooltip('${currentTagFilter}: ${filtered} stories')`);
  }
}

/**
 * Show tooltip for stories rings (separate from progress page)
 */
function showStoriesRingTooltip(text) {
  const tooltip = document.getElementById('stories-ring-tooltip');
  if (tooltip) {
    tooltip.textContent = text;
    tooltip.classList.add('visible');
  }
}

/**
 * Hide stories ring tooltip
 */
function hideStoriesRingTooltip() {
  const tooltip = document.getElementById('stories-ring-tooltip');
  if (tooltip) {
    tooltip.classList.remove('visible');
  }
}

/**
 * Animate a progress ring to a target value
 */
function animateRing(ringId, progress, radius) {
  const ring = document.getElementById(ringId);
  if (!ring) return;

  const circumference = 2 * Math.PI * radius;
  const offset = circumference * (1 - progress);

  ring.style.strokeDasharray = circumference;
  ring.style.strokeDashoffset = offset;
}

/**
 * Render the tag filter chips
 */
function renderTagFilter(stories) {
  const chips = document.getElementById('tag-filter-chips');
  if (!chips) return;

  // Collect all unique tags with counts
  const tagCounts = {};
  stories.forEach(story => {
    story.tags.forEach(tag => {
      tagCounts[tag] = (tagCounts[tag] || 0) + 1;
    });
  });

  // Sort by count (most common first)
  const sortedTags = Object.entries(tagCounts)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 6); // Limit to 6 tags

  chips.innerHTML = `
    <button class="tag-chip ${currentTagFilter === 'all' ? 'tag-chip--active' : ''}"
            data-tag="all" onclick="filterByTag('all')">All</button>
    ${sortedTags.map(([tag, count]) => `
      <button class="tag-chip ${currentTagFilter === tag ? 'tag-chip--active' : ''}"
              data-tag="${tag}" onclick="filterByTag('${tag}')"
              style="${currentTagFilter === tag ? `background: ${TAG_COLORS[tag] || '#7A5A9A'}; color: white;` : ''}">
        ${tag} <span class="tag-count">${count}</span>
      </button>
    `).join('')}
  `;
}

/**
 * Filter stories by tag
 */
function filterByTag(tag) {
  currentTagFilter = tag;
  renderStoryShelf();
}

/**
 * Render the filler word trend mini-chart
 */
function renderFillerTrend(stories) {
  const chart = document.getElementById('filler-trend-chart');
  const insight = document.getElementById('filler-trend-insight');
  if (!chart) return;

  // Get last 8 sessions
  const recent = stories.slice(-8);
  const rates = recent.map(s => s.fillersPerMinute || 0);
  const maxRate = Math.max(...rates, 1);

  chart.innerHTML = rates.map(rate => {
    const height = Math.max(4, (rate / maxRate) * 40);
    return `<div class="filler-bar" style="height: ${height}px"></div>`;
  }).join('');

  // Generate insight
  if (rates.length >= 2) {
    const first = rates[0];
    const last = rates[rates.length - 1];
    if (last < first * 0.7) {
      insight.textContent = `You're using ${Math.round((1 - last/first) * 100)}% fewer filler words. Great progress!`;
      document.getElementById('tip-filler-words').style.display = 'block';
      document.getElementById('tip-filler-text').textContent = insight.textContent;
    } else if (last > first * 1.3) {
      insight.textContent = 'Filler words increased recently. Try pausing between thoughts.';
    } else {
      insight.textContent = 'Filler words staying consistent. Keep practicing!';
    }
  }
}

/**
 * Capture a story from practice session
 * Called when user completes a practice
 */
function captureStory(transcript, questionType, duration) {
  const data = getStories();

  // Count filler words
  const fillerCounts = {};
  let totalFillers = 0;
  const lowerTranscript = transcript.toLowerCase();

  FILLER_WORDS.forEach(filler => {
    const regex = new RegExp(`\\b${filler}\\b`, 'gi');
    const matches = lowerTranscript.match(regex);
    if (matches) {
      fillerCounts[filler] = matches.length;
      totalFillers += matches.length;
    }
  });

  const durationMinutes = duration / 60;
  const fillersPerMinute = durationMinutes > 0 ? totalFillers / durationMinutes : 0;

  // Extract story name (simplified version)
  let name = questionType + ' Story';
  const projectMatch = transcript.match(/(?:the|a|our)\s+(\w+\s+(?:project|migration|system|launch|team))/i);
  if (projectMatch) {
    name = projectMatch[1].replace(/^\w/, c => c.toUpperCase());
  }

  // Generate tags
  const tags = [questionType.toLowerCase()];
  if (/team|led|managed/i.test(transcript)) tags.push('leadership');
  if (/technical|code|system/i.test(transcript)) tags.push('technical');
  if (/conflict|disagree/i.test(transcript)) tags.push('conflict');
  if (/result|outcome|improved|increased/i.test(transcript)) tags.push('results-driven');

  // Calculate readiness
  const readiness = Math.min(100, Math.max(20, 100 - (fillersPerMinute * 15) + 20));

  // Generate insight
  let insight = 'Keep practicing to polish this story.';
  if (fillersPerMinute < 2) {
    insight = 'Smooth delivery! This story is getting interview-ready.';
  } else if (fillersPerMinute > 5) {
    insight = 'Try taking a breath between thoughts to reduce filler words.';
  }

  const story = {
    id: 'story_' + Date.now(),
    name,
    tags: [...new Set(tags)].slice(0, 4),
    readiness: Math.round(readiness),
    fillersPerMinute: Math.round(fillersPerMinute * 10) / 10,
    fillerCounts,
    insight,
    questionType,
    created: new Date().toISOString(),
    practices: 1
  };

  data.stories.push(story);
  data.stats.sessions = (data.stats.sessions || 0) + 1;
  saveStories(data);

  // Show capture notification
  showStoryCaptureCard(story);

  return story;
}

/**
 * Show the story capture notification card
 */
function showStoryCaptureCard(story) {
  const card = document.getElementById('story-capture-card');
  if (!card) return;

  document.getElementById('captured-story-name').textContent = story.name;
  document.getElementById('captured-story-tags').innerHTML =
    story.tags.map(t => `<span class="story-tag">${t}</span>`).join('');
  document.getElementById('captured-story-insight').textContent = story.insight;

  card.style.display = 'block';

  // Auto-hide after 8 seconds
  setTimeout(() => {
    card.style.display = 'none';
  }, 8000);
}

/**
 * Hide the story capture card
 */
function hideStoryCaptureCard() {
  const card = document.getElementById('story-capture-card');
  if (card) card.style.display = 'none';
}

/**
 * Export stories as JSON
 */
function exportStories() {
  const data = getStories();
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `preptalk-stories-${new Date().toISOString().split('T')[0]}.json`;
  a.click();
  URL.revokeObjectURL(url);
}

// ============================================
// UPSTREAM STORY SUGGESTIONS
// ============================================

// Map question types to relevant tags for matching
const QUESTION_TAG_MAP = {
  'Leadership': ['leadership', 'mentorship', 'collaboration'],
  'Technical': ['technical', 'problem-solving', 'innovation'],
  'Conflict': ['conflict', 'communication', 'negotiation'],
  'Teamwork': ['collaboration', 'leadership', 'mentorship'],
  'Problem Solving': ['problem-solving', 'technical', 'results-driven'],
  'Growth': ['growth', 'mentorship', 'leadership']
};

// Currently selected suggestion for use
let selectedSuggestion = null;

/**
 * Find stories that match a question type.
 * Returns stories sorted by readiness (most ready first).
 *
 * @param {string} questionType - The type of question (e.g., 'Leadership')
 * @returns {Array} Matching stories sorted by readiness
 */
function getRelevantStories(questionType) {
  const data = getStories();
  const relevantTags = QUESTION_TAG_MAP[questionType] || [];

  // Score each story by how many relevant tags it has
  const scored = data.stories.map(story => {
    const matchCount = story.tags.filter(tag => relevantTags.includes(tag)).length;
    return { ...story, matchScore: matchCount };
  });

  // Filter to stories with at least one matching tag, sort by readiness
  return scored
    .filter(s => s.matchScore > 0)
    .sort((a, b) => b.readiness - a.readiness);
}

/**
 * Show story suggestions panel for the current question.
 * Called when entering the practice screen.
 *
 * @param {string} questionType - The type of question being asked
 */
function showStorySuggestions(questionType) {
  const suggestions = getRelevantStories(questionType);
  const panel = document.getElementById('story-suggestions');
  const list = document.getElementById('story-suggestions-list');

  if (!panel || !list) return;

  if (suggestions.length === 0) {
    panel.style.display = 'none';
    return;
  }

  // Show top 2 suggestions
  const topSuggestions = suggestions.slice(0, 2);
  selectedSuggestion = topSuggestions[0];

  list.innerHTML = topSuggestions.map((story, idx) => {
    const status = story.readiness >= 80 ? 'ready' : story.readiness >= 40 ? 'practicing' : 'new';
    const statusLabel = status === 'ready' ? 'Interview-ready' : status === 'practicing' ? 'Practiced' : 'New';
    const practiceText = story.practices === 1 ? '1 time' : `${story.practices} times`;

    return `
      <div class="story-suggestion-item ${idx === 0 ? 'selected' : ''}" data-id="${story.id}" onclick="selectSuggestion('${story.id}')">
        <div class="suggestion-name">${story.name}</div>
        <div class="suggestion-meta">
          <span class="suggestion-status suggestion-status--${status}">${statusLabel}</span>
          <span class="suggestion-practices">Practiced ${practiceText}</span>
        </div>
      </div>
    `;
  }).join('');

  panel.style.display = 'block';
}

/**
 * Select a story suggestion
 */
function selectSuggestion(storyId) {
  const data = getStories();
  selectedSuggestion = data.stories.find(s => s.id === storyId);

  // Update UI selection
  document.querySelectorAll('.story-suggestion-item').forEach(item => {
    item.classList.toggle('selected', item.dataset.id === storyId);
  });
}

/**
 * Use the selected story suggestion.
 * Navigates to practice with the story context.
 */
function useStorySuggestion() {
  if (!selectedSuggestion) return;

  // Update the resume cue sidebar with the selected story
  const cueCard = document.querySelector('.sidebar .tip-card-accent .tip-text');
  if (cueCard) {
    cueCard.textContent = `Using your "${selectedSuggestion.name}" story. You've practiced this ${selectedSuggestion.practices} time${selectedSuggestion.practices === 1 ? '' : 's'}.`;
  }

  hideStorySuggestions();
}

/**
 * Hide the story suggestions panel
 */
function hideStorySuggestions() {
  const panel = document.getElementById('story-suggestions');
  if (panel) panel.style.display = 'none';
}

// ============================================
// STORY PRACTICE (RESCORING)
// ============================================

let currentPracticeStory = null;
let practiceRecording = false;
let practiceStartTime = null;
let practiceTimerInterval = null;

/**
 * Open the story practice modal for a specific story.
 *
 * @param {string} storyId - The ID of the story to practice
 */
function openStoryPractice(storyId) {
  const data = getStories();
  const story = data.stories.find(s => s.id === storyId);

  if (!story) {
    console.warn('PrepTalk: Story not found:', storyId);
    return;
  }

  currentPracticeStory = story;

  // Populate modal
  document.getElementById('practice-story-name').textContent = story.name;
  document.getElementById('practice-readiness-bar').style.width = story.readiness + '%';
  document.getElementById('practice-readiness-value').textContent = story.readiness + '%';
  document.getElementById('practice-count').textContent = story.practices;
  document.getElementById('practice-tags').innerHTML =
    story.tags.map(t => `<span class="story-tag">${t}</span>`).join('');

  // Set dynamic tip based on story state
  const tipEl = document.getElementById('practice-tip');
  if (story.readiness >= 80) {
    tipEl.textContent = 'This story is interview-ready. Practice to keep it sharp.';
  } else if (story.fillersPerMinute > 4) {
    tipEl.textContent = 'Focus on pausing between thoughts instead of filling silence.';
  } else if (story.readiness < 50) {
    tipEl.textContent = 'Take your time. Each practice builds your confidence.';
  } else {
    tipEl.textContent = 'You\'re getting close. One or two more practices should do it.';
  }

  // Reset recording state
  resetPracticeRecording();

  // Show modal
  document.getElementById('story-practice-modal').style.display = 'flex';
  document.body.style.overflow = 'hidden';
}

/**
 * Close the story practice modal
 */
function closeStoryPractice() {
  stopPracticeTimer();
  currentPracticeStory = null;
  practiceRecording = false;

  document.getElementById('story-practice-modal').style.display = 'none';
  document.body.style.overflow = '';

  // Refresh the shelf to show updated scores
  renderStoryShelf();
}

/**
 * Reset the practice recording UI
 */
function resetPracticeRecording() {
  practiceRecording = false;
  practiceStartTime = null;

  document.getElementById('practice-recording-area').style.display = 'block';
  document.getElementById('practice-results').style.display = 'none';
  document.getElementById('practice-mic-btn').classList.remove('recording');
  document.getElementById('practice-mic-label').textContent = 'Start recording';
  document.getElementById('practice-timer').textContent = '0:00';

  stopPracticeTimer();
}

/**
 * Toggle story recording on/off
 */
function toggleStoryRecording() {
  if (!practiceRecording) {
    startPracticeRecording();
  } else {
    stopPracticeRecording();
  }
}

/**
 * Start practice recording
 */
function startPracticeRecording() {
  practiceRecording = true;
  practiceStartTime = Date.now();

  document.getElementById('practice-mic-btn').classList.add('recording');
  document.getElementById('practice-mic-label').textContent = 'Recording... Click to stop';

  // Start timer
  practiceTimerInterval = setInterval(updatePracticeTimer, 1000);
}

/**
 * Stop practice recording and calculate new score
 */
function stopPracticeRecording() {
  practiceRecording = false;
  stopPracticeTimer();

  const duration = (Date.now() - practiceStartTime) / 1000;
  document.getElementById('practice-mic-btn').classList.remove('recording');
  document.getElementById('practice-mic-label').textContent = 'Processing...';

  // Simulate processing delay for realism
  setTimeout(() => {
    rescoreStory(duration);
  }, 800);
}

/**
 * Update the practice timer display
 */
function updatePracticeTimer() {
  if (!practiceStartTime) return;

  const elapsed = Math.floor((Date.now() - practiceStartTime) / 1000);
  const minutes = Math.floor(elapsed / 60);
  const seconds = elapsed % 60;

  document.getElementById('practice-timer').textContent =
    `${minutes}:${seconds.toString().padStart(2, '0')}`;
}

/**
 * Stop the practice timer
 */
function stopPracticeTimer() {
  if (practiceTimerInterval) {
    clearInterval(practiceTimerInterval);
    practiceTimerInterval = null;
  }
}

/**
 * Rescore the story based on practice.
 * Simulates improvement based on practice count and duration.
 *
 * @param {number} duration - Practice duration in seconds
 */
function rescoreStory(duration) {
  if (!currentPracticeStory) return;

  const data = getStories();
  const storyIndex = data.stories.findIndex(s => s.id === currentPracticeStory.id);

  if (storyIndex === -1) return;

  const story = data.stories[storyIndex];
  const oldReadiness = story.readiness;

  // Calculate improvement based on:
  // - Practice count (diminishing returns after 5)
  // - Duration (sweet spot is 90-180 seconds)
  // - Current readiness (harder to improve when already high)

  let improvement = 0;

  // Base improvement from practice (diminishing returns)
  const practiceBonus = Math.max(2, 12 - (story.practices * 1.5));
  improvement += practiceBonus;

  // Duration bonus (optimal is 90-180 seconds)
  if (duration >= 60 && duration <= 240) {
    improvement += 3;
  } else if (duration >= 30 && duration <= 300) {
    improvement += 1;
  }

  // Harder to improve at higher levels
  if (oldReadiness > 80) {
    improvement = improvement * 0.3;
  } else if (oldReadiness > 60) {
    improvement = improvement * 0.6;
  }

  // Simulate filler word improvement
  const fillerImprovement = 0.1 + (Math.random() * 0.3);
  const newFillersPerMinute = Math.max(0.5, story.fillersPerMinute - fillerImprovement);

  // Calculate new readiness
  const newReadiness = Math.min(100, Math.round(oldReadiness + improvement));

  // Update story
  story.readiness = newReadiness;
  story.fillersPerMinute = Math.round(newFillersPerMinute * 10) / 10;
  story.practices += 1;

  // Update insight
  if (newReadiness >= 90) {
    story.insight = 'Interview-ready. You own this story.';
  } else if (newReadiness >= 75) {
    story.insight = 'Getting sharp. A bit more practice and you\'re there.';
  } else if (newReadiness >= 50) {
    story.insight = 'Good progress. The structure is solid.';
  } else {
    story.insight = 'Keep practicing. Each time gets easier.';
  }

  data.stats.sessions = (data.stats.sessions || 0) + 1;
  saveStories(data);

  // Update current reference
  currentPracticeStory = story;

  // Show results
  showPracticeResults(oldReadiness, newReadiness, duration);
}

/**
 * Show the practice results comparison
 */
function showPracticeResults(oldReadiness, newReadiness, duration) {
  document.getElementById('practice-recording-area').style.display = 'none';
  document.getElementById('practice-results').style.display = 'block';

  // Update comparison
  document.getElementById('result-before').textContent = oldReadiness + '%';
  document.getElementById('result-after').textContent = newReadiness + '%';

  // Update readiness bar
  document.getElementById('practice-readiness-bar').style.width = newReadiness + '%';
  document.getElementById('practice-readiness-value').textContent = newReadiness + '%';
  document.getElementById('practice-count').textContent = currentPracticeStory.practices;

  // Set result messaging
  const improvement = newReadiness - oldReadiness;
  const iconEl = document.getElementById('practice-result-icon');
  const titleEl = document.getElementById('practice-result-title');
  const insightEl = document.getElementById('practice-result-insight');

  if (improvement >= 8) {
    iconEl.textContent = 'ðŸŽ¯';
    titleEl.textContent = 'Significant improvement!';
    insightEl.textContent = 'That practice really paid off. Your delivery is getting stronger.';
  } else if (improvement >= 3) {
    iconEl.textContent = 'âœ“';
    titleEl.textContent = 'Nice progress';
    insightEl.textContent = 'Every practice session builds muscle memory. Keep it up.';
  } else if (improvement > 0) {
    iconEl.textContent = 'ðŸ“ˆ';
    titleEl.textContent = 'Steady progress';
    insightEl.textContent = 'You\'re maintaining and slightly improving. That\'s exactly how mastery works.';
  } else {
    iconEl.textContent = 'ðŸ’ª';
    titleEl.textContent = 'Holding steady';
    insightEl.textContent = 'You\'re at a high level. Maintenance practice keeps you sharp.';
  }
}

/**
 * Practice the same story again
 */
function practiceAgain() {
  resetPracticeRecording();
}

// ============================================
// INITIALIZATION
// ============================================

/**
 * Initializes the prototype on DOM ready.
 * Checks for existing session and restores state if found.
 */
function initPrototype() {
  const state = getState();

  if (state.lastUpdated) {
    console.log(
      'PrepTalk: Restoring session from',
      new Date(state.lastUpdated).toLocaleString()
    );
    restoreState();
  } else {
    console.log('PrepTalk: No existing session found, starting fresh');
    saveState({ currentScreen: 'screen-welcome' });
  }

  // Initialize demo stories if shelf is empty (for demonstration)
  initDemoStories();

  // Initialize story shelf
  renderStoryShelf();

  // Show story suggestions when entering practice screen
  showStorySuggestions('Leadership');
}

// Enhanced navigation that triggers story suggestions
const originalGoToScreen = goToScreen;
window.goToScreen = function(screenId) {
  originalGoToScreen(screenId);

  // When entering practice screen, show relevant story suggestions
  if (screenId === 'screen-practice') {
    // Get current question type from the meta text
    const metaEl = document.querySelector('#screen-practice .text--meta');
    const questionType = metaEl ? metaEl.textContent.split('â€¢')[1]?.trim() || 'Leadership' : 'Leadership';
    showStorySuggestions(questionType);
  }
};

// Initialize on DOM ready
document.addEventListener('DOMContentLoaded', initPrototype);
